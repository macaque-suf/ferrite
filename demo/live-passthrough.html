<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WASM Audio Ferrite - Live Audio Passthrough</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 20px;
            color: #fff;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 40px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .warning {
            background: rgba(255, 193, 7, 0.2);
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .warning h3 {
            color: #ffc107;
            margin-bottom: 10px;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        h2 {
            margin-bottom: 20px;
            color: #ffd700;
            font-size: 1.5rem;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }
        
        label {
            flex: 1;
            color: rgba(255, 255, 255, 0.9);
        }
        
        select, input[type="range"], input[type="number"] {
            flex: 1;
            max-width: 200px;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.3);
            color: white;
        }
        
        input[type="range"] {
            cursor: pointer;
        }
        
        .range-value {
            min-width: 60px;
            text-align: right;
            font-family: 'Courier New', monospace;
            color: #ffd700;
        }
        
        button {
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        button.active {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        button.stop {
            background: linear-gradient(135deg, #ff6b6b 0%, #ff4757 100%);
        }
        
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }
        
        .meters {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .meter {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
        }
        
        .meter h3 {
            color: #ffd700;
            margin-bottom: 10px;
            font-size: 1rem;
        }
        
        .meter-bar {
            width: 100%;
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }
        
        .meter-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
            transition: width 0.1s ease;
            position: absolute;
            left: 0;
            top: 0;
        }
        
        .meter-value {
            position: absolute;
            width: 100%;
            text-align: center;
            line-height: 30px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            z-index: 1;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }
        
        .stat-label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
            margin-bottom: 5px;
        }
        
        .stat-value {
            color: #ffd700;
            font-size: 1.2rem;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
        
        .stat-value.good {
            color: #00ff00;
        }
        
        .stat-value.warning {
            color: #ffff00;
        }
        
        .stat-value.bad {
            color: #ff6b6b;
        }
        
        .visualizer {
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            margin-top: 20px;
        }
        
        canvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }
        
        .status {
            padding: 10px;
            border-radius: 8px;
            margin-top: 20px;
            text-align: center;
            font-weight: bold;
        }
        
        .status.active {
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #00ff00;
        }
        
        .status.inactive {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .status.error {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff0000;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé§ Live Audio Passthrough Test</h1>
        
        <div class="warning">
            <h3>‚ö†Ô∏è Headphone Warning</h3>
            <p>Use headphones to avoid feedback! The processed audio will be played through your speakers/headphones in real-time.</p>
        </div>
        
        <div class="main-grid">
            <!-- Configuration Section -->
            <div class="section">
                <h2>‚öôÔ∏è Audio Configuration</h2>
                <div class="controls">
                    <div class="control-group">
                        <label for="inputDevice">Input Device:</label>
                        <select id="inputDevice">
                            <option value="">Default Microphone</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="bufferSize">Buffer Size:</label>
                        <select id="bufferSize">
                            <option value="128">128 samples (2.7ms @ 48kHz)</option>
                            <option value="256" selected>256 samples (5.3ms @ 48kHz)</option>
                            <option value="512">512 samples (10.7ms @ 48kHz)</option>
                            <option value="1024">1024 samples (21.3ms @ 48kHz)</option>
                            <option value="2048">2048 samples (42.7ms @ 48kHz)</option>
                            <option value="4096">4096 samples (85.3ms @ 48kHz)</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="sampleRate">Sample Rate:</label>
                        <select id="sampleRate">
                            <option value="22050">22050 Hz</option>
                            <option value="44100">44100 Hz</option>
                            <option value="48000" selected>48000 Hz</option>
                            <option value="96000">96000 Hz</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="processingMode">Processing Mode:</label>
                        <select id="processingMode">
                            <option value="passthrough">Passthrough (No Processing)</option>
                            <option value="regular">Regular API (process)</option>
                            <option value="zerocopy" selected>Zero-Copy API (processPtr)</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="reductionAmount">Noise Reduction:</label>
                        <input type="range" id="reductionAmount" min="0" max="1" step="0.01" value="0.3">
                        <span class="range-value" id="reductionValue">0.30</span>
                    </div>
                    
                    <div class="control-group">
                        <label for="outputGain">Output Gain:</label>
                        <input type="range" id="outputGain" min="0" max="2" step="0.01" value="1">
                        <span class="range-value" id="gainValue">1.00</span>
                    </div>
                </div>
                
                <div class="button-group">
                    <button id="initBtn" onclick="initializeSystem()">Initialize WASM</button>
                    <button id="startBtn" onclick="startPassthrough()" disabled>Start Passthrough</button>
                    <button id="stopBtn" onclick="stopPassthrough()" disabled class="stop">Stop</button>
                    <button id="captureNoiseBtn" onclick="captureNoise()" disabled>Capture Noise</button>
                </div>
                
                <div id="status" class="status inactive">System Inactive</div>
            </div>
            
            <!-- Performance Monitoring Section -->
            <div class="section">
                <h2>üìä Performance Metrics</h2>
                
                <div class="meters">
                    <div class="meter">
                        <h3>Input Level</h3>
                        <div class="meter-bar">
                            <div class="meter-value" id="inputLevelText">-‚àû dB</div>
                            <div class="meter-fill" id="inputLevel" style="width: 0%"></div>
                        </div>
                    </div>
                    <div class="meter">
                        <h3>Output Level</h3>
                        <div class="meter-bar">
                            <div class="meter-value" id="outputLevelText">-‚àû dB</div>
                            <div class="meter-fill" id="outputLevel" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
                
                <div class="stats-grid">
                    <div class="stat">
                        <div class="stat-label">Processing Time</div>
                        <div class="stat-value" id="processingTime">0.00 ms</div>
                    </div>
                    <div class="stat">
                        <div class="stat-label">Latency</div>
                        <div class="stat-value" id="latency">0.0 ms</div>
                    </div>
                    <div class="stat">
                        <div class="stat-label">CPU Usage</div>
                        <div class="stat-value" id="cpuUsage">0.0%</div>
                    </div>
                    <div class="stat">
                        <div class="stat-label">Buffer Utilization</div>
                        <div class="stat-value" id="bufferUtil">0.0%</div>
                    </div>
                    <div class="stat">
                        <div class="stat-label">Frames/sec</div>
                        <div class="stat-value" id="fps">0</div>
                    </div>
                    <div class="stat">
                        <div class="stat-label">Dropouts</div>
                        <div class="stat-value" id="dropouts">0</div>
                    </div>
                </div>
                
                <div class="visualizer">
                    <canvas id="waveform"></canvas>
                </div>
            </div>
        </div>
        
        <!-- Detailed Stats Section -->
        <div class="section">
            <h2>üìà Detailed Statistics</h2>
            <div class="stats-grid">
                <div class="stat">
                    <div class="stat-label">Avg Processing</div>
                    <div class="stat-value" id="avgProcessing">0.00 ms</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Min Processing</div>
                    <div class="stat-value" id="minProcessing">0.00 ms</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Max Processing</div>
                    <div class="stat-value" id="maxProcessing">0.00 ms</div>
                </div>
                <div class="stat">
                    <div class="stat-label">P95 Processing</div>
                    <div class="stat-value" id="p95Processing">0.00 ms</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Total Frames</div>
                    <div class="stat-value" id="totalFrames">0</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Memory Used</div>
                    <div class="stat-value" id="memoryUsed">0 MB</div>
                </div>
                <div class="stat">
                    <div class="stat-label">WASM Memory</div>
                    <div class="stat-value" id="wasmMemory">0 MB</div>
                </div>
                <div class="stat">
                    <div class="stat-label">GC Count</div>
                    <div class="stat-value" id="gcCount">0</div>
                </div>
            </div>
        </div>
    </div>
    
    <script type="module">
        // Global state
        window.audioContext = null;
        window.sourceNode = null;
        window.processorNode = null;
        window.gainNode = null;
        window.analyserNode = null;
        window.stream = null;
        window.wasmModule = null;
        window.wasmMemory = null;
        window.wasmInputPtr = 0;
        window.wasmOutputPtr = 0;
        window.isProcessing = false;
        window.isCapturingNoise = false;
        
        // Performance tracking
        window.performanceStats = {
            processingTimes: [],
            frameCount: 0,
            dropoutCount: 0,
            startTime: 0,
            lastGCCount: 0
        };
        
        // Initialize system
        window.initializeSystem = async function() {
            const statusEl = document.getElementById('status');
            statusEl.textContent = 'Initializing...';
            statusEl.className = 'status inactive';
            
            try {
                // Initialize audio context
                window.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: parseInt(document.getElementById('sampleRate').value),
                    latencyHint: 'interactive'
                });
                
                // Load WASM module
                const wasmModule = await import('./wasm/audio_processor_core.js');
                const wasmInstance = await wasmModule.default();
                
                const { NoiseReducer } = wasmModule;
                window.wasmModule = new NoiseReducer(window.audioContext.sampleRate);
                window.wasmExports = wasmModule;
                
                // Configure the noise reducer for processing
                window.wasmModule.set_spectral_enabled(true);
                window.wasmModule.set_gate_enabled(false);
                window.wasmModule.set_reduction_amount(0.3);
                
                // Try to get WASM memory - this is critical for zero-copy
                if (wasmInstance && wasmInstance.memory) {
                    window.wasmMemory = wasmInstance.memory;
                    console.log('Got memory from wasmInstance.memory');
                } else if (wasmModule.__wbindgen_export_0) {
                    window.wasmMemory = wasmModule.__wbindgen_export_0;
                    console.log('Got memory from __wbindgen_export_0');
                } else if (wasmModule.memory) {
                    window.wasmMemory = wasmModule.memory;
                    console.log('Got memory from wasmModule.memory');
                } else {
                    console.warn('Could not get WASM memory - zero-copy will not work');
                }
                
                // Get available audio devices
                await enumerateDevices();
                
                // Enable buttons
                document.getElementById('startBtn').disabled = false;
                document.getElementById('captureNoiseBtn').disabled = false;
                
                statusEl.textContent = 'System Ready';
                statusEl.className = 'status inactive';
                
                console.log('System initialized:', {
                    audioContext: window.audioContext,
                    wasmModule: window.wasmModule,
                    wasmMemory: window.wasmMemory,
                    wasmExports: window.wasmExports
                });
                
            } catch (error) {
                console.error('Initialization failed:', error);
                statusEl.textContent = `Error: ${error.message}`;
                statusEl.className = 'status error';
            }
        };
        
        // Enumerate audio devices
        async function enumerateDevices() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const inputSelect = document.getElementById('inputDevice');
                inputSelect.innerHTML = '<option value="">Default Microphone</option>';
                
                devices.forEach(device => {
                    if (device.kind === 'audioinput') {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.textContent = device.label || `Microphone ${device.deviceId.substr(0, 5)}`;
                        inputSelect.appendChild(option);
                    }
                });
            } catch (error) {
                console.error('Failed to enumerate devices:', error);
            }
        }
        
        // Start passthrough
        window.startPassthrough = async function() {
            if (window.isProcessing) return;
            
            const statusEl = document.getElementById('status');
            statusEl.textContent = 'Starting...';
            
            try {
                // Get user media
                const constraints = {
                    audio: {
                        deviceId: document.getElementById('inputDevice').value || undefined,
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: window.audioContext.sampleRate
                    }
                };
                
                window.stream = await navigator.mediaDevices.getUserMedia(constraints);
                window.sourceNode = window.audioContext.createMediaStreamSource(window.stream);
                
                // Create processor node
                const bufferSize = parseInt(document.getElementById('bufferSize').value);
                window.processorNode = window.audioContext.createScriptProcessor(bufferSize, 1, 1);
                
                // Pre-allocate WASM buffers for zero-copy mode
                if (window.wasmModule && window.wasmModule.alloc_buffer) {
                    window.wasmInputPtr = window.wasmModule.alloc_buffer(bufferSize);
                    window.wasmOutputPtr = window.wasmModule.alloc_buffer(bufferSize);
                }
                
                // Set up processing
                window.processorNode.onaudioprocess = processAudio;
                
                // Create gain node
                window.gainNode = window.audioContext.createGain();
                window.gainNode.gain.value = parseFloat(document.getElementById('outputGain').value);
                
                // Create analyser for visualization
                window.analyserNode = window.audioContext.createAnalyser();
                window.analyserNode.fftSize = 2048;
                
                // Connect nodes
                window.sourceNode.connect(window.processorNode);
                window.processorNode.connect(window.gainNode);
                window.gainNode.connect(window.analyserNode);
                window.analyserNode.connect(window.audioContext.destination);
                
                // Start visualization
                startVisualization();
                
                // Reset stats
                window.performanceStats = {
                    processingTimes: [],
                    frameCount: 0,
                    dropoutCount: 0,
                    startTime: performance.now(),
                    lastGCCount: performance.memory ? performance.memory.usedJSHeapSize : 0
                };
                
                window.isProcessing = true;
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                
                statusEl.textContent = 'Processing Active';
                statusEl.className = 'status active';
                
            } catch (error) {
                console.error('Failed to start passthrough:', error);
                statusEl.textContent = `Error: ${error.message}`;
                statusEl.className = 'status error';
            }
        };
        
        // Stop passthrough
        window.stopPassthrough = function() {
            if (!window.isProcessing) return;
            
            window.isProcessing = false;
            
            // Disconnect nodes
            if (window.sourceNode) window.sourceNode.disconnect();
            if (window.processorNode) window.processorNode.disconnect();
            if (window.gainNode) window.gainNode.disconnect();
            if (window.analyserNode) window.analyserNode.disconnect();
            
            // Stop stream
            if (window.stream) {
                window.stream.getTracks().forEach(track => track.stop());
                window.stream = null;
            }
            
            // Clean up
            window.sourceNode = null;
            window.processorNode = null;
            window.gainNode = null;
            window.analyserNode = null;
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            
            const statusEl = document.getElementById('status');
            statusEl.textContent = 'System Ready';
            statusEl.className = 'status inactive';
            
            // Show final stats
            updateDetailedStats();
        };
        
        // Helper to get WASM memory
        function getWasmMemory() {
            if (window.wasmMemory) return window.wasmMemory;
            
            if (window.wasmExports) {
                if (window.wasmExports.__wbindgen_export_0) {
                    window.wasmMemory = window.wasmExports.__wbindgen_export_0;
                    return window.wasmMemory;
                }
                if (window.wasmExports.memory) {
                    window.wasmMemory = window.wasmExports.memory;
                    return window.wasmMemory;
                }
            }
            
            return null;
        }
        
        // Process audio
        function processAudio(event) {
            const inputBuffer = event.inputBuffer.getChannelData(0);
            const outputBuffer = event.outputBuffer.getChannelData(0);
            const processingMode = document.getElementById('processingMode').value;
            
            const startTime = performance.now();
            
            try {
                if (processingMode === 'passthrough') {
                    // Direct passthrough
                    outputBuffer.set(inputBuffer);
                } else if (processingMode === 'regular') {
                    // Regular API
                    const processed = window.wasmModule.process(inputBuffer);
                    outputBuffer.set(new Float32Array(processed));
                } else if (processingMode === 'zerocopy') {
                    // Zero-copy API
                    const memory = getWasmMemory();
                    
                    if (memory && window.wasmInputPtr) {
                        // Create view into WASM memory
                        const wasmInput = new Float32Array(
                            memory.buffer, 
                            window.wasmInputPtr, 
                            inputBuffer.length
                        );
                        
                        // Copy input data to WASM memory
                        wasmInput.set(inputBuffer);
                        
                        // Process in place
                        window.wasmModule.processPtr(window.wasmInputPtr, inputBuffer.length);
                        
                        // Copy processed data back to output
                        outputBuffer.set(wasmInput);
                        
                        // Debug: Check if data changed
                        if (window.performanceStats.frameCount % 100 === 0) {
                            const inputRMS = Math.sqrt(inputBuffer.reduce((sum, x) => sum + x * x, 0) / inputBuffer.length);
                            const outputRMS = Math.sqrt(outputBuffer.reduce((sum, x) => sum + x * x, 0) / outputBuffer.length);
                            console.log('Zero-copy processing - Input RMS:', inputRMS.toFixed(4), 'Output RMS:', outputRMS.toFixed(4));
                        }
                    } else {
                        console.warn('Zero-copy not available, falling back to regular API');
                        // Fallback to regular API
                        const processed = window.wasmModule.process(inputBuffer);
                        outputBuffer.set(new Float32Array(processed));
                    }
                }
                
                // Capture noise if needed
                if (window.isCapturingNoise && window.wasmModule) {
                    window.wasmModule.learn_noise(inputBuffer);
                }
                
            } catch (error) {
                console.error('Processing error:', error);
                outputBuffer.set(inputBuffer); // Passthrough on error
                window.performanceStats.dropoutCount++;
            }
            
            const processingTime = performance.now() - startTime;
            
            // Update stats
            window.performanceStats.processingTimes.push(processingTime);
            window.performanceStats.frameCount++;
            
            // Keep only last 1000 measurements
            if (window.performanceStats.processingTimes.length > 1000) {
                window.performanceStats.processingTimes.shift();
            }
            
            // Update UI (throttled)
            if (window.performanceStats.frameCount % 10 === 0) {
                updateStats(processingTime);
            }
            
            // Update levels
            updateLevels(inputBuffer, outputBuffer);
        }
        
        // Capture noise profile
        window.captureNoise = function() {
            if (!window.wasmModule) {
                alert('Please initialize WASM first');
                return;
            }
            
            window.isCapturingNoise = true;
            const btn = document.getElementById('captureNoiseBtn');
            btn.textContent = 'Capturing...';
            btn.disabled = true;
            
            // Capture 2 seconds of noise
            setTimeout(() => {
                window.isCapturingNoise = false;
                btn.textContent = 'Capture Noise';
                btn.disabled = false;
                alert('Noise profile captured!');
            }, 2000);
        };
        
        // Update performance stats
        function updateStats(currentProcessingTime) {
            const times = window.performanceStats.processingTimes;
            if (times.length === 0) return;
            
            // Calculate statistics
            const avg = times.reduce((a, b) => a + b, 0) / times.length;
            const sorted = [...times].sort((a, b) => a - b);
            const min = sorted[0];
            const max = sorted[sorted.length - 1];
            const p95 = sorted[Math.floor(times.length * 0.95)];
            
            // Calculate buffer duration
            const bufferSize = parseInt(document.getElementById('bufferSize').value);
            const sampleRate = window.audioContext.sampleRate;
            const bufferDuration = (bufferSize / sampleRate) * 1000;
            
            // Update UI
            document.getElementById('processingTime').textContent = `${currentProcessingTime.toFixed(3)} ms`;
            document.getElementById('latency').textContent = `${(bufferDuration + avg).toFixed(1)} ms`;
            document.getElementById('cpuUsage').textContent = `${((avg / bufferDuration) * 100).toFixed(1)}%`;
            document.getElementById('bufferUtil').textContent = `${((avg / bufferDuration) * 100).toFixed(1)}%`;
            
            const fps = 1000 / bufferDuration;
            document.getElementById('fps').textContent = Math.round(fps);
            document.getElementById('dropouts').textContent = window.performanceStats.dropoutCount;
            
            // Color code based on performance
            const cpuEl = document.getElementById('cpuUsage');
            const utilPercent = (avg / bufferDuration) * 100;
            cpuEl.className = utilPercent < 10 ? 'stat-value good' : 
                             utilPercent < 50 ? 'stat-value warning' : 'stat-value bad';
        }
        
        // Update detailed statistics
        function updateDetailedStats() {
            const times = window.performanceStats.processingTimes;
            if (times.length === 0) return;
            
            const avg = times.reduce((a, b) => a + b, 0) / times.length;
            const sorted = [...times].sort((a, b) => a - b);
            const min = sorted[0];
            const max = sorted[sorted.length - 1];
            const p95 = sorted[Math.floor(times.length * 0.95)];
            
            document.getElementById('avgProcessing').textContent = `${avg.toFixed(3)} ms`;
            document.getElementById('minProcessing').textContent = `${min.toFixed(3)} ms`;
            document.getElementById('maxProcessing').textContent = `${max.toFixed(3)} ms`;
            document.getElementById('p95Processing').textContent = `${p95.toFixed(3)} ms`;
            document.getElementById('totalFrames').textContent = window.performanceStats.frameCount;
            
            // Memory stats
            if (performance.memory) {
                const memoryMB = performance.memory.usedJSHeapSize / 1024 / 1024;
                document.getElementById('memoryUsed').textContent = `${memoryMB.toFixed(1)} MB`;
            }
            
            if (window.wasmMemory) {
                const wasmMB = window.wasmMemory.buffer.byteLength / 1024 / 1024;
                document.getElementById('wasmMemory').textContent = `${wasmMB.toFixed(1)} MB`;
            }
        }
        
        // Update level meters
        function updateLevels(inputBuffer, outputBuffer) {
            const inputRMS = Math.sqrt(inputBuffer.reduce((sum, x) => sum + x * x, 0) / inputBuffer.length);
            const outputRMS = Math.sqrt(outputBuffer.reduce((sum, x) => sum + x * x, 0) / outputBuffer.length);
            
            const inputDB = 20 * Math.log10(Math.max(inputRMS, 0.00001));
            const outputDB = 20 * Math.log10(Math.max(outputRMS, 0.00001));
            
            // Map to percentage (0dB = 100%, -60dB = 0%)
            const inputPercent = Math.max(0, Math.min(100, (inputDB + 60) / 60 * 100));
            const outputPercent = Math.max(0, Math.min(100, (outputDB + 60) / 60 * 100));
            
            document.getElementById('inputLevel').style.width = `${inputPercent}%`;
            document.getElementById('outputLevel').style.width = `${outputPercent}%`;
            document.getElementById('inputLevelText').textContent = `${inputDB.toFixed(1)} dB`;
            document.getElementById('outputLevelText').textContent = `${outputDB.toFixed(1)} dB`;
        }
        
        // Visualization
        function startVisualization() {
            const canvas = document.getElementById('waveform');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            const bufferLength = window.analyserNode.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            function draw() {
                if (!window.isProcessing) return;
                requestAnimationFrame(draw);
                
                window.analyserNode.getByteTimeDomainData(dataArray);
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#00ff00';
                ctx.beginPath();
                
                const sliceWidth = canvas.width / bufferLength;
                let x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * canvas.height / 2;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                    
                    x += sliceWidth;
                }
                
                ctx.lineTo(canvas.width, canvas.height / 2);
                ctx.stroke();
            }
            
            draw();
        }
        
        // UI event handlers
        document.getElementById('reductionAmount').addEventListener('input', (e) => {
            document.getElementById('reductionValue').textContent = parseFloat(e.target.value).toFixed(2);
            if (window.wasmModule) {
                window.wasmModule.set_reduction_amount(parseFloat(e.target.value));
            }
        });
        
        document.getElementById('outputGain').addEventListener('input', (e) => {
            document.getElementById('gainValue').textContent = parseFloat(e.target.value).toFixed(2);
            if (window.gainNode) {
                window.gainNode.gain.value = parseFloat(e.target.value);
            }
        });
        
        // Auto-update detailed stats
        setInterval(() => {
            if (window.isProcessing) {
                updateDetailedStats();
            }
        }, 1000);
    </script>
</body>
</html>