<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WASM Audio Ferrite - Zero-Copy Performance Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #fff;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 40px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .test-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        h2 {
            margin-bottom: 20px;
            color: #ffd700;
            font-size: 1.5rem;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        button {
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        button.active {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        .results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .result-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 20px;
            position: relative;
        }
        
        .result-card h3 {
            color: #ffd700;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }
        
        .metric-label {
            color: rgba(255, 255, 255, 0.8);
        }
        
        .metric-value {
            color: #fff;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
        
        .metric-value.good {
            color: #00ff00;
        }
        
        .metric-value.bad {
            color: #ff6b6b;
        }
        
        .chart-container {
            height: 200px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            margin-top: 10px;
            position: relative;
            overflow: hidden;
        }
        
        canvas {
            width: 100%;
            height: 100%;
        }
        
        .status {
            padding: 10px;
            border-radius: 8px;
            margin-top: 20px;
            text-align: center;
            font-weight: bold;
        }
        
        .status.success {
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #00ff00;
        }
        
        .status.error {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff0000;
        }
        
        .status.info {
            background: rgba(0, 150, 255, 0.2);
            border: 1px solid #0096ff;
        }
        
        .loader {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ Zero-Copy API Performance Test</h1>
        
        <!-- Test Configuration -->
        <div class="test-section">
            <h2>‚öôÔ∏è Test Configuration</h2>
            <div class="controls">
                <div>
                    <label for="bufferSize">Buffer Size (samples):</label>
                    <select id="bufferSize">
                        <option value="128">128</option>
                        <option value="256">256</option>
                        <option value="512" selected>512</option>
                        <option value="1024">1024</option>
                        <option value="2048">2048</option>
                        <option value="4096">4096</option>
                    </select>
                </div>
                <div>
                    <label for="iterations">Iterations:</label>
                    <select id="iterations">
                        <option value="100">100</option>
                        <option value="500">500</option>
                        <option value="1000" selected>1000</option>
                        <option value="5000">5000</option>
                        <option value="10000">10000</option>
                    </select>
                </div>
                <div>
                    <label for="sampleRate">Sample Rate:</label>
                    <select id="sampleRate">
                        <option value="22050">22050 Hz</option>
                        <option value="44100">44100 Hz</option>
                        <option value="48000" selected>48000 Hz</option>
                        <option value="96000">96000 Hz</option>
                    </select>
                </div>
            </div>
            
            <div class="controls">
                <button id="initBtn" onclick="initializeWasm()">Initialize WASM</button>
                <button id="warmupBtn" onclick="runWarmup()" disabled>Warm Up</button>
                <button id="testRegularBtn" onclick="runRegularTest()" disabled>Test Regular API</button>
                <button id="testZeroCopyBtn" onclick="runZeroCopyTest()" disabled>Test Zero-Copy API</button>
                <button id="compareBtn" onclick="runComparison()" disabled>Run Full Comparison</button>
            </div>
            
            <div id="status" class="status info" style="display: none;"></div>
            
            <div class="progress-bar" id="progressBar" style="display: none;">
                <div class="progress-fill" id="progressFill">0%</div>
            </div>
        </div>
        
        <!-- Test Results -->
        <div class="test-section">
            <h2>üìä Performance Results</h2>
            <div class="results">
                <!-- Regular API Results -->
                <div class="result-card">
                    <h3>Regular API (process)</h3>
                    <div class="metric">
                        <span class="metric-label">Average Time:</span>
                        <span class="metric-value" id="regular-avg">-</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Min Time:</span>
                        <span class="metric-value" id="regular-min">-</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Max Time:</span>
                        <span class="metric-value" id="regular-max">-</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">P95 Time:</span>
                        <span class="metric-value" id="regular-p95">-</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Std Dev:</span>
                        <span class="metric-value" id="regular-stddev">-</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Throughput:</span>
                        <span class="metric-value" id="regular-throughput">-</span>
                    </div>
                    <div class="chart-container">
                        <canvas id="regular-chart"></canvas>
                    </div>
                </div>
                
                <!-- Zero-Copy API Results -->
                <div class="result-card">
                    <h3>Zero-Copy API (processPtr)</h3>
                    <div class="metric">
                        <span class="metric-label">Average Time:</span>
                        <span class="metric-value" id="zerocopy-avg">-</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Min Time:</span>
                        <span class="metric-value" id="zerocopy-min">-</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Max Time:</span>
                        <span class="metric-value" id="zerocopy-max">-</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">P95 Time:</span>
                        <span class="metric-value" id="zerocopy-p95">-</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Std Dev:</span>
                        <span class="metric-value" id="zerocopy-stddev">-</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Throughput:</span>
                        <span class="metric-value" id="zerocopy-throughput">-</span>
                    </div>
                    <div class="chart-container">
                        <canvas id="zerocopy-chart"></canvas>
                    </div>
                </div>
                
                <!-- Comparison -->
                <div class="result-card">
                    <h3>Comparison</h3>
                    <div class="metric">
                        <span class="metric-label">Speed Improvement:</span>
                        <span class="metric-value" id="comparison-speedup">-</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Latency Reduction:</span>
                        <span class="metric-value" id="comparison-latency">-</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Memory Allocations Saved:</span>
                        <span class="metric-value" id="comparison-allocations">-</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">GC Pressure Reduction:</span>
                        <span class="metric-value" id="comparison-gc">-</span>
                    </div>
                    <div class="chart-container">
                        <canvas id="comparison-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Memory Analysis -->
        <div class="test-section">
            <h2>üíæ Memory Analysis</h2>
            <div class="results">
                <div class="result-card">
                    <h3>Memory Usage</h3>
                    <div class="metric">
                        <span class="metric-label">Heap Used (Regular):</span>
                        <span class="metric-value" id="memory-regular-heap">-</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Heap Used (Zero-Copy):</span>
                        <span class="metric-value" id="memory-zerocopy-heap">-</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">WASM Memory:</span>
                        <span class="metric-value" id="memory-wasm">-</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Peak Allocation:</span>
                        <span class="metric-value" id="memory-peak">-</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script type="module">
        // Global state
        window.wasmModule = null;
        window.wasmMemory = null;
        window.wasmInputPtr = 0;
        window.wasmOutputPtr = 0;
        window.testResults = {
            regular: [],
            zeroCopy: []
        };
        
        // Initialize WASM
        window.initializeWasm = async function() {
            showStatus('Initializing WASM module...', 'info', true);
            
            try {
                // Load WASM module
                const wasmModule = await import('./wasm/audio_processor_core.js');
                const wasmInstance = await wasmModule.default();
                
                const { NoiseReducer } = wasmModule;
                
                // Create noise reducer instance
                const sampleRate = parseInt(document.getElementById('sampleRate').value);
                window.wasmModule = new NoiseReducer(sampleRate);
                
                // Store the entire module for accessing internals
                window.wasmExports = wasmModule;
                
                // Try multiple ways to get WASM memory
                if (wasmInstance && wasmInstance.memory) {
                    window.wasmMemory = wasmInstance.memory;
                    console.log('Got memory from wasmInstance.memory');
                } else if (wasmModule.__wbindgen_export_0) {
                    // This is likely the memory export from wasm-bindgen
                    window.wasmMemory = wasmModule.__wbindgen_export_0;
                    console.log('Got memory from __wbindgen_export_0');
                } else if (wasmModule.memory) {
                    window.wasmMemory = wasmModule.memory;
                    console.log('Got memory from wasmModule.memory');
                } else {
                    // Try to find it through the instance's exports
                    console.warn('Could not find WASM memory directly, trying workaround...');
                    // We'll get it dynamically when needed
                }
                
                // Enable test buttons
                document.getElementById('warmupBtn').disabled = false;
                document.getElementById('testRegularBtn').disabled = false;
                document.getElementById('testZeroCopyBtn').disabled = false;
                document.getElementById('compareBtn').disabled = false;
                
                showStatus('WASM module initialized successfully!', 'success');
                console.log('WASM Module:', window.wasmModule);
                console.log('WASM Exports:', window.wasmExports);
                console.log('WASM Memory:', window.wasmMemory);
                
            } catch (error) {
                console.error('Failed to initialize WASM:', error);
                showStatus(`Failed to initialize WASM: ${error.message}`, 'error');
            }
        };
        
        // Helper function to get WASM memory
        function getWasmMemory() {
            // Try to get memory from various sources
            if (window.wasmMemory) {
                return window.wasmMemory;
            }
            
            // Try to get from exports
            if (window.wasmExports) {
                // Check for wasm-bindgen memory export
                if (window.wasmExports.__wbindgen_export_0) {
                    window.wasmMemory = window.wasmExports.__wbindgen_export_0;
                    return window.wasmMemory;
                }
                if (window.wasmExports.memory) {
                    window.wasmMemory = window.wasmExports.memory;
                    return window.wasmMemory;
                }
            }
            
            // Try to get from the module instance directly
            if (window.wasmModule) {
                // Check if there's a way to get memory through the instance
                const proto = Object.getPrototypeOf(window.wasmModule);
                const ctor = proto.constructor;
                
                // Look for memory in the constructor or its properties
                if (ctor.memory) {
                    window.wasmMemory = ctor.memory;
                    return window.wasmMemory;
                }
            }
            
            console.error('Could not access WASM memory');
            return null;
        }
        
        // Warm up the JIT compiler
        window.runWarmup = async function() {
            if (!window.wasmModule) {
                showStatus('Please initialize WASM first', 'error');
                return;
            }
            
            showStatus('Warming up...', 'info', true);
            const bufferSize = parseInt(document.getElementById('bufferSize').value);
            const testData = new Float32Array(bufferSize);
            
            // Fill with test signal
            for (let i = 0; i < bufferSize; i++) {
                testData[i] = Math.sin(2 * Math.PI * 440 * i / 48000) * 0.5;
            }
            
            // Warm up regular API
            for (let i = 0; i < 100; i++) {
                window.wasmModule.process(testData);
            }
            
            // Warm up zero-copy API if available
            if (window.wasmModule.alloc_buffer) {
                try {
                    window.wasmInputPtr = window.wasmModule.alloc_buffer(bufferSize);
                    window.wasmOutputPtr = window.wasmModule.alloc_buffer(bufferSize);
                    
                    const memory = getWasmMemory();
                    if (memory) {
                        const wasmInput = new Float32Array(memory.buffer, window.wasmInputPtr, bufferSize);
                        wasmInput.set(testData);
                        
                        for (let i = 0; i < 100; i++) {
                            window.wasmModule.processPtr(window.wasmInputPtr, bufferSize);
                        }
                    } else {
                        console.warn('Zero-copy warm-up skipped - no WASM memory access');
                    }
                } catch (error) {
                    console.warn('Zero-copy warm-up failed:', error);
                }
            }
            
            showStatus('Warm-up complete!', 'success');
        };
        
        // Test regular API
        window.runRegularTest = async function() {
            if (!window.wasmModule) {
                showStatus('Please initialize WASM first', 'error');
                return;
            }
            
            const bufferSize = parseInt(document.getElementById('bufferSize').value);
            const iterations = parseInt(document.getElementById('iterations').value);
            
            showStatus(`Testing Regular API (${iterations} iterations)...`, 'info', true);
            showProgress(0);
            
            // Create test data
            const testData = new Float32Array(bufferSize);
            for (let i = 0; i < bufferSize; i++) {
                testData[i] = Math.sin(2 * Math.PI * 440 * i / 48000) * 0.5 + 
                              (Math.random() - 0.5) * 0.1; // Signal + noise
            }
            
            const times = [];
            const startMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
            
            for (let i = 0; i < iterations; i++) {
                if (i % 100 === 0) {
                    showProgress((i / iterations) * 100);
                    await new Promise(resolve => setTimeout(resolve, 0)); // Yield to UI
                }
                
                const start = performance.now();
                const result = window.wasmModule.process(testData);
                const end = performance.now();
                
                times.push(end - start);
            }
            
            const endMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
            const memoryUsed = (endMemory - startMemory) / 1024 / 1024;
            
            showProgress(100);
            hideProgress();
            
            // Calculate statistics
            const stats = calculateStats(times);
            window.testResults.regular = times;
            
            // Display results
            displayResults('regular', stats);
            drawChart('regular-chart', times);
            
            document.getElementById('memory-regular-heap').textContent = `${memoryUsed.toFixed(2)} MB`;
            
            showStatus(`Regular API test complete! Avg: ${stats.avg.toFixed(3)}ms`, 'success');
        };
        
        // Test zero-copy API
        window.runZeroCopyTest = async function() {
            if (!window.wasmModule) {
                showStatus('Please initialize WASM first', 'error');
                return;
            }
            
            if (!window.wasmModule.alloc_buffer) {
                showStatus('Zero-copy API not available in this WASM build', 'error');
                return;
            }
            
            const bufferSize = parseInt(document.getElementById('bufferSize').value);
            const iterations = parseInt(document.getElementById('iterations').value);
            
            showStatus(`Testing Zero-Copy API (${iterations} iterations)...`, 'info', true);
            showProgress(0);
            
            try {
                // Get WASM memory
                const memory = getWasmMemory();
                if (!memory) {
                    showStatus('Cannot access WASM memory for zero-copy test', 'error');
                    return;
                }
                
                // Allocate WASM buffers
                window.wasmInputPtr = window.wasmModule.alloc_buffer(bufferSize);
                const wasmInput = new Float32Array(memory.buffer, window.wasmInputPtr, bufferSize);
                
                // Create test data directly in WASM memory
                for (let i = 0; i < bufferSize; i++) {
                    wasmInput[i] = Math.sin(2 * Math.PI * 440 * i / 48000) * 0.5 + 
                                   (Math.random() - 0.5) * 0.1; // Signal + noise
                }
                
                const times = [];
                const startMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                
                for (let i = 0; i < iterations; i++) {
                    if (i % 100 === 0) {
                        showProgress((i / iterations) * 100);
                        await new Promise(resolve => setTimeout(resolve, 0)); // Yield to UI
                    }
                    
                    const start = performance.now();
                    window.wasmModule.processPtr(window.wasmInputPtr, bufferSize);
                    const end = performance.now();
                    
                    times.push(end - start);
                }
                
                const endMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                const memoryUsed = (endMemory - startMemory) / 1024 / 1024;
                
                showProgress(100);
                hideProgress();
                
                // Calculate statistics
                const stats = calculateStats(times);
                window.testResults.zeroCopy = times;
                
                // Display results
                displayResults('zerocopy', stats);
                drawChart('zerocopy-chart', times);
                
                document.getElementById('memory-zerocopy-heap').textContent = `${memoryUsed.toFixed(2)} MB`;
                
                // Display WASM memory info
                const wasmMemoryMB = memory.buffer.byteLength / 1024 / 1024;
                document.getElementById('memory-wasm').textContent = `${wasmMemoryMB.toFixed(2)} MB`;
                
                showStatus(`Zero-Copy API test complete! Avg: ${stats.avg.toFixed(3)}ms`, 'success');
                
            } catch (error) {
                console.error('Zero-copy test failed:', error);
                showStatus(`Zero-copy test failed: ${error.message}`, 'error');
                hideProgress();
            }
        };
        
        // Run full comparison
        window.runComparison = async function() {
            await runWarmup();
            await runRegularTest();
            await runZeroCopyTest();
            
            // Calculate comparison metrics
            if (window.testResults.regular.length > 0 && window.testResults.zeroCopy.length > 0) {
                const regularStats = calculateStats(window.testResults.regular);
                const zeroCopyStats = calculateStats(window.testResults.zeroCopy);
                
                const speedup = regularStats.avg / zeroCopyStats.avg;
                const latencyReduction = ((regularStats.avg - zeroCopyStats.avg) / regularStats.avg * 100);
                const iterations = window.testResults.regular.length;
                const allocationsPerIteration = 2; // input and output arrays
                const allocationsSaved = iterations * allocationsPerIteration;
                
                document.getElementById('comparison-speedup').textContent = `${speedup.toFixed(2)}x faster`;
                document.getElementById('comparison-speedup').className = 'metric-value good';
                
                document.getElementById('comparison-latency').textContent = `${latencyReduction.toFixed(1)}%`;
                document.getElementById('comparison-latency').className = 'metric-value good';
                
                document.getElementById('comparison-allocations').textContent = allocationsSaved.toLocaleString();
                document.getElementById('comparison-allocations').className = 'metric-value good';
                
                document.getElementById('comparison-gc').textContent = 'Significantly Reduced';
                document.getElementById('comparison-gc').className = 'metric-value good';
                
                // Draw comparison chart
                drawComparisonChart('comparison-chart', regularStats, zeroCopyStats);
            }
            
            showStatus('Full comparison complete!', 'success');
        };
        
        // Calculate statistics
        function calculateStats(times) {
            const sorted = [...times].sort((a, b) => a - b);
            const sum = times.reduce((a, b) => a + b, 0);
            const avg = sum / times.length;
            const min = sorted[0];
            const max = sorted[sorted.length - 1];
            const p95 = sorted[Math.floor(times.length * 0.95)];
            
            // Calculate standard deviation
            const squaredDiffs = times.map(t => Math.pow(t - avg, 2));
            const avgSquaredDiff = squaredDiffs.reduce((a, b) => a + b, 0) / times.length;
            const stddev = Math.sqrt(avgSquaredDiff);
            
            // Calculate throughput (samples per second)
            const bufferSize = parseInt(document.getElementById('bufferSize').value);
            const samplesPerMs = bufferSize / avg;
            const throughput = samplesPerMs * 1000;
            
            return { avg, min, max, p95, stddev, throughput };
        }
        
        // Display results
        function displayResults(prefix, stats) {
            document.getElementById(`${prefix}-avg`).textContent = `${stats.avg.toFixed(3)} ms`;
            document.getElementById(`${prefix}-min`).textContent = `${stats.min.toFixed(3)} ms`;
            document.getElementById(`${prefix}-max`).textContent = `${stats.max.toFixed(3)} ms`;
            document.getElementById(`${prefix}-p95`).textContent = `${stats.p95.toFixed(3)} ms`;
            document.getElementById(`${prefix}-stddev`).textContent = `${stats.stddev.toFixed(3)} ms`;
            document.getElementById(`${prefix}-throughput`).textContent = `${(stats.throughput / 1000000).toFixed(2)} M samples/s`;
        }
        
        // Draw chart
        function drawChart(canvasId, times) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw histogram
            const buckets = 50;
            const min = Math.min(...times);
            const max = Math.max(...times);
            const range = max - min;
            const bucketSize = range / buckets;
            const histogram = new Array(buckets).fill(0);
            
            times.forEach(time => {
                const bucket = Math.min(Math.floor((time - min) / bucketSize), buckets - 1);
                histogram[bucket]++;
            });
            
            const maxCount = Math.max(...histogram);
            const barWidth = width / buckets;
            
            ctx.fillStyle = '#667eea';
            histogram.forEach((count, i) => {
                const barHeight = (count / maxCount) * height * 0.9;
                ctx.fillRect(i * barWidth, height - barHeight, barWidth - 1, barHeight);
            });
            
            // Draw average line
            const avgX = ((times.reduce((a, b) => a + b, 0) / times.length - min) / range) * width;
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(avgX, 0);
            ctx.lineTo(avgX, height);
            ctx.stroke();
        }
        
        // Draw comparison chart
        function drawComparisonChart(canvasId, regularStats, zeroCopyStats) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw bar chart
            const metrics = ['avg', 'min', 'max', 'p95'];
            const barWidth = width / (metrics.length * 2 + 1);
            const maxValue = Math.max(
                regularStats.avg, regularStats.max, regularStats.p95,
                zeroCopyStats.avg, zeroCopyStats.max, zeroCopyStats.p95
            );
            
            metrics.forEach((metric, i) => {
                const x = (i * 2 + 0.5) * barWidth;
                
                // Regular API bar
                const regularHeight = (regularStats[metric] / maxValue) * height * 0.8;
                ctx.fillStyle = '#ff6b6b';
                ctx.fillRect(x, height - regularHeight, barWidth * 0.8, regularHeight);
                
                // Zero-copy API bar
                const zeroCopyHeight = (zeroCopyStats[metric] / maxValue) * height * 0.8;
                ctx.fillStyle = '#51cf66';
                ctx.fillRect(x + barWidth, height - zeroCopyHeight, barWidth * 0.8, zeroCopyHeight);
                
                // Labels
                ctx.fillStyle = '#fff';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(metric.toUpperCase(), x + barWidth, height - 5);
            });
        }
        
        // UI helpers
        function showStatus(message, type, showLoader = false) {
            const element = document.getElementById('status');
            element.style.display = 'block';
            element.className = `status ${type}`;
            element.innerHTML = message + (showLoader ? '<span class="loader"></span>' : '');
            
            if (type === 'success' && !showLoader) {
                setTimeout(() => {
                    element.style.display = 'none';
                }, 3000);
            }
        }
        
        function showProgress(percent) {
            const bar = document.getElementById('progressBar');
            const fill = document.getElementById('progressFill');
            bar.style.display = 'block';
            fill.style.width = `${percent}%`;
            fill.textContent = `${Math.round(percent)}%`;
        }
        
        function hideProgress() {
            setTimeout(() => {
                document.getElementById('progressBar').style.display = 'none';
            }, 500);
        }
        
        // Auto-initialize on load
        window.addEventListener('load', () => {
            if (!window.WebAssembly) {
                showStatus('WebAssembly is not supported in this browser', 'error');
                document.getElementById('initBtn').disabled = true;
            }
            
            // Check for performance.memory API
            if (!performance.memory) {
                console.warn('performance.memory API not available - memory metrics will be limited');
            }
        });
    </script>
</body>
</html>